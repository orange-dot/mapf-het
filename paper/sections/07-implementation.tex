\section{Implementation}
\label{sec:implementation}

We describe the implementation architecture spanning from planning algorithms to embedded execution.

\subsection{Planning Layer (Go)}

The MAPF-HET planning algorithms are implemented in Go, comprising approximately 7,000 lines of code organized as follows:

\begin{table}[htbp]
\centering
\caption{Planning Layer Code Organization}
\label{tab:code}
\begin{tabular}{@{}lr@{}}
\toprule
Component & Lines \\
\midrule
\texttt{internal/algo/mixed\_cbs.go} & 850 \\
\texttt{internal/algo/energy\_cbs.go} & 720 \\
\texttt{internal/algo/deadline\_cbs.go} & 580 \\
\texttt{internal/algo/hybrid\_cbs.go} & 640 \\
\texttt{internal/algo/astar3d.go} & 450 \\
\texttt{internal/algo/potential\_field.go} & 380 \\
\texttt{internal/core/airspace.go} & 520 \\
\texttt{internal/core/workspace.go} & 680 \\
\texttt{internal/core/conflict.go} & 440 \\
Other modules & 1,740 \\
\midrule
\textbf{Total} & \textbf{7,000} \\
\bottomrule
\end{tabular}
\end{table}

Key implementation decisions:
\begin{itemize}
    \item \textbf{Conflict detection:} Spatial hashing with $O(1)$ average-case lookup
    \item \textbf{Priority queue:} Fibonacci heap for CBS OPEN list ($O(\log n)$ extract-min)
    \item \textbf{Path representation:} Compressed waypoint format with interpolation
    \item \textbf{Energy simulation:} Discrete-event simulation with 100ms resolution
\end{itemize}

\subsection{Execution Layer (C/Rust)}

The \ekkor{} kernel provides dual implementations for embedded targets:

\textbf{C Implementation:} Targets STM32G474 with FreeRTOS, prioritizing deterministic timing and minimal footprint. Key characteristics:
\begin{itemize}
    \item Q15.16 fixed-point arithmetic throughout
    \item Static memory allocation (no malloc after init)
    \item Interrupt-safe lock-free data structures
    \item 12 KB Flash, 4 KB RAM footprint
\end{itemize}

\textbf{Rust Implementation:} Uses Embassy async framework, providing memory safety guarantees with equivalent performance:
\begin{itemize}
    \item \texttt{no\_std} compatible, no heap allocation
    \item Compile-time race condition prevention
    \item Same memory layout as C for interoperability
    \item Ferrocene-compatible for safety certification path
\end{itemize}

Both implementations share test vectors ensuring behavioral equivalence.

\subsection{Communication Protocol}

CAN-FD message allocation follows priority ordering:

\begin{table}[htbp]
\centering
\caption{CAN-FD Message ID Allocation}
\label{tab:can}
\begin{tabular}{@{}lll@{}}
\toprule
Range & Category & Bandwidth \\
\midrule
0x000-0x00F & Emergency & <1\% \\
0x010-0x0FF & Safety bus & 5\% \\
0x100-0x1FF & Coordination & 42\% \\
0x200-0x3FF & Control & 30\% \\
0x400-0x7FF & Diagnostics & 22\% \\
\bottomrule
\end{tabular}
\end{table}

Coordination messages (heartbeat, field updates, neighbor announcements) consume 42\% of the 5 Mbps CAN-FD bandwidth at 64-node segment capacity.

\subsection{Network Architecture}

The hierarchical network supports 500-2000 modules:
\begin{itemize}
    \item \textbf{Segment:} 50-100 modules on CAN-FD at 5 Mbps
    \item \textbf{Backbone:} 10-20 segment gateways interconnected
    \item \textbf{Safety bus:} Gateways to L2 supervisor at 1 Mbps
\end{itemize}

Each STM32G474 gateway uses three FDCAN peripherals: segment (FDCAN1), backbone (FDCAN2), and safety (FDCAN3).

\subsection{Verification Infrastructure}

Formal verification employs multiple tools:
\begin{itemize}
    \item \textbf{Kani:} Bounded model checking for Rust coordination logic
    \item \textbf{CBMC:} C bounded model checking for safety-critical paths
    \item \textbf{TLA+:} Protocol specification for consensus and partition handling
    \item \textbf{Property tests:} QuickCheck-style fuzzing with 10,000+ test cases
\end{itemize}

Test vectors in JSON format ensure C and Rust implementations produce identical outputs for coordination field updates, slack computation, and capability matching.

\subsection{Build and Deployment}

\begin{verbatim}
# Planning layer
cd mapf-het-research
go build ./cmd/mapfhet
go test ./...

# Embedded (Rust)
cd ek-kor2/rust
cargo build --release --target thumbv7em-none-eabihf
cargo test --target x86_64-unknown-linux-gnu

# Embedded (C)
cd ek-kor2/c
make TARGET=stm32g474
make test
\end{verbatim}

Continuous integration runs all tests on every commit, including cross-compilation verification and test vector validation.
